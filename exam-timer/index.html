<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Exam Timer Manager v3.0</title>
    <style>
        /* CSS Variables for theming */
        :root {
            --bg-primary: #ffffff;
            --bg-secondary: #f5f5f5;
            --bg-card: #ffffff;
            --text-primary: #1a1a1a;
            --text-secondary: #666666;
            --border-color: #e0e0e0;
            --accent-color: #2563eb;
            --success-color: #16a34a;
            --warning-color: #ea580c;
            --danger-color: #dc2626;
            --paused-color: #f59e0b;
            --break-color: #8b5cf6;
            --shadow: 0 2px 8px rgba(0,0,0,0.1);
            --shadow-hover: 0 4px 12px rgba(0,0,0,0.15);
        }

        [data-theme="dark"] {
            --bg-primary: #1a1a1a;
            --bg-secondary: #2a2a2a;
            --bg-card: #2a2a2a;
            --text-primary: #f0f0f0;
            --text-secondary: #a0a0a0;
            --border-color: #404040;
            --accent-color: #3b82f6;
            --success-color: #22c55e;
            --warning-color: #f97316;
            --danger-color: #ef4444;
            --paused-color: #fbbf24;
            --break-color: #a78bfa;
            --shadow: 0 2px 8px rgba(0,0,0,0.3);
            --shadow-hover: 0 4px 12px rgba(0,0,0,0.4);
        }

        /* Base styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            transition: background-color 0.3s, color 0.3s;
        }

        /* Header styles */
        .header {
            position: sticky;
            top: 0;
            left: 0;
            right: 0;
            background-color: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            padding: 0.75rem 1rem;
            z-index: 100;
            box-shadow: var(--shadow);
        }

        .header-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
            align-items: center;
            justify-content: center;
            max-width: 1400px;
            margin: 0 auto;
            position: relative; /* For positioning context */
            padding-right: 40px; /* Space for help button */
        }

        .control-group {
            display: flex;
            gap: 0.4rem;
            align-items: center;
        }

        /* Button styles */
        button {
            padding: 0.3rem 0.8rem;
            border: none;
            border-radius: 3px;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            background-color: var(--accent-color);
            color: white;
        }

        button:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: var(--shadow-hover);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        button.secondary {
            background-color: var(--bg-card);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        button.danger {
            background-color: var(--danger-color);
        }

        button.success {
            background-color: var(--success-color);
        }

        button.warning {
            background-color: var(--warning-color);
        }

        button.break-btn {
            background-color: var(--break-color);
            min-width: 100px;
        }

        .break-btn span {
            /* This ensures the click registers on the button, not the changing text */
            pointer-events: none;
        }

        button.break-btn.active {
            background-color: var(--warning-color);
            font-weight: 600;
        }

        .icon-button {
            width: 25px;
            height: 25px;
            padding: 0 0 0 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
        }

        .help-button-container {
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
        }

        /* Toggle switch styles */
        .toggle-switch {
            position: relative;
            width: 50px;
            height: 24px;
            background-color: var(--border-color);
            border-radius: 12px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .toggle-switch.active {
            background-color: var(--accent-color);
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: white;
            top: 2px;
            left: 2px;
            transition: transform 0.3s;
        }

        .toggle-switch.active::after {
            transform: translateX(26px);
        }

        /* Slider styles */
        .slider-container {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        input[type="range"] {
            width: 100px;
            height: 4px;
            border-radius: 1px;
            background: var(--border-color);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent-color);
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent-color);
            cursor: pointer;
            border: none;
        }

        /* Main content area */
        .main-content {
            flex: 1;
            padding: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Timer grid */
        .timer-grid {
            display: grid;
            gap: 0.75rem;
            width: 100%;
            max-width: 1400px;
        }

        .timer-grid.single {
            grid-template-columns: 1fr;
            max-width: 700px;
        }

        .timer-grid.multiple {
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
        }

        /* Timer card styles */
        .timer-card {
            background-color: var(--bg-card);
            border: 2px solid var(--border-color);
            border-radius: 6px;
            padding: 0.75rem;
            box-shadow: var(--shadow);
            transition: all 0.3s;
        }

        .timer-card.paused {
            border-color: var(--paused-color);
            box-shadow: 0 0 20px rgba(245, 158, 11, 0.2);
        }

        .timer-card.on-break {
            border-color: var(--break-color);
            box-shadow: 0 0 20px rgba(139, 92, 246, 0.2);
        }

        .timer-card.finished {
            border-color: var(--danger-color);
            box-shadow: 0 0 20px rgba(220, 38, 38, 0.2);
        }

        .timer-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.4rem;
        }

        .timer-label {
            font-size: 1.15rem;
            font-weight: 600;
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            border-radius: 2px;
            transition: background-color 0.2s;
            position: relative;
        }

        .timer-label:hover {
            background-color: var(--bg-secondary);
        }

        .timer-label:hover::after {
            content: 'âœï¸';
            position: absolute;
            right: -20px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 0.8rem;
        }

        .timer-label input {
            background: transparent;
            border: 1px solid var(--accent-color);
            padding: 0.25rem 0.5rem;
            font-size: inherit;
            font-weight: inherit;
            color: inherit;
            border-radius: 2px;
            width: 200px;
        }

        /* Timer display */
        .timer-display {
            font-size: 4.5rem;
            font-weight: 200;
            text-align: center;
            margin: 0.5rem 0;
            cursor: pointer;
            padding: 0.25rem;
            border-radius: 4px;
            transition: background-color 0.2s;
            font-variant-numeric: tabular-nums;
            line-height: 1;
            white-space: nowrap;
            overflow-x: auto;
            scrollbar-width: none;
        }
        .timer-display::-webkit-scrollbar {
            display: none;
        }

        .timer-grid.single .timer-display {
            font-size: 6rem;
        }

        .timer-display:hover:not(.running) {
            background-color: var(--bg-secondary);
        }

        .timer-display.running {
            cursor: default;
        }

        .timer-display.finished {
            color: var(--danger-color);
            cursor: default;
            font-size: 3rem;
        }

        /* Progress bar */
        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: var(--border-color);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background-color: var(--accent-color);
            transition: width 0.3s ease;
        }

        .progress-container {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            margin: 0.5rem 0;
        }

        .duration-label {
            font-size: 0.85rem;
            color: var(--text-secondary);
            white-space: nowrap;
            min-width: fit-content;
        }

        /* Timer Controls Layout */
        .timer-controls {
            display: flex;
            gap: 0.4rem;
            justify-content: space-between; /* This is key */
            align-items: center;
            margin-top: 0.5rem;
            flex-wrap: wrap;
        }

        .timer-controls-left, .timer-controls-right {
            display: flex;
            flex-wrap: wrap;
            gap: 0.4rem;
            align-items: center;
        }


        .timer-controls button {
            padding: 0.3rem 0.7rem;
            font-size: 0.8rem;
            height: 25px;
        }

        /* Compact layout (> 4 timers) */
        .timer-card.compact .timer-and-progress {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin: 0.5rem 0;
        }

        .timer-card.compact .timer-display {
            font-size: 2.25rem;
            font-weight: 300;
            margin: 0;
            padding: 0;
            text-align: left;
            flex-shrink: 0;
        }

        .timer-card.compact .progress-container {
            flex-grow: 1;
            margin: 0;
        }


        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background-color: var(--bg-card);
            padding: 1.5rem;
            border-radius: 6px;
            box-shadow: var(--shadow-hover);
            max-width: 400px;
            width: 90%;
        }

        .modal-header {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 1rem;
        }

        .modal-body {
            margin-bottom: 1.5rem;
        }

        .modal-footer {
            display: flex;
            gap: 0.4rem;
            justify-content: flex-end;
        }

        .input-group {
            margin-bottom: 1rem;
        }

        .input-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .input-group input {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            border-radius: 2px;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            font-size: 1rem;
        }

        /* Empty state */
        .empty-state {
            text-align: center;
            color: var(--text-secondary);
        }

        .empty-state h2 {
            font-size: 1.5rem;
            margin-bottom: 1rem;
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .timer-grid.multiple {
                grid-template-columns: 1fr;
            }

            .timer-display {
                font-size: 3rem;
            }

            .timer-grid.single .timer-display {
                font-size: 4rem;
            }
        }

        @media (min-width: 769px) {
             .timer-grid.multiple {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <!-- Header with global controls -->
    <header class="header" id="header">
        <div class="header-controls">
            <div class="control-group">
                <button id="startAllBtn" onclick="startAllTimers()">Start All</button>
                <button id="pauseAllBtn" onclick="pauseAllTimers()">Pause All</button>
                <button id="resetAllBtn" onclick="resetAllTimers()">Reset All</button>
                <button id="removeAllBtn" class="danger" onclick="removeAllTimers()">Remove All</button>
            </div>

            <div class="control-group">
                <label>Direction:</label>
                <div class="toggle-switch" id="directionToggle" onclick="toggleDirection()">
                </div>
                <span id="directionLabel">Count Down</span>
            </div>

            <div class="control-group slider-container">
                <label>ðŸ”Š</label>
                <input type="range" id="volumeSlider" min="0" max="100" value="50" onchange="updateVolume(this.value)" oninput="updateVolume(this.value)">
                <span id="volumeLabel">50%</span>
            </div>

            <div class="control-group">
                <button id="lockBtn" class="secondary" onclick="toggleUILock()">ðŸ”“ Unlocked</button>
            </div>

            <div class="control-group">
                <div class="toggle-switch" id="themeToggle" onclick="toggleTheme()">
                </div>
                <span>Dark Mode</span>
            </div>

            <div class="control-group">
                <button id="addTimerBtn" class="success" onclick="addTimer()">+ Add Timer</button>
            </div>

            <div class="help-button-container">
                <button class="secondary icon-button" onclick="window.open('README.html', '_blank')" title="Help & Instructions">?</button>
            </div>
        </div>
    </header>

    <!-- Main content area -->
    <main class="main-content" id="mainContent">
        <div id="timerContainer" class="timer-grid">
            <div class="empty-state">
                <h2>No timers yet</h2>
                <p>Click "Add Timer" to get started</p>
            </div>
        </div>
    </main>

    <!-- Modals -->
    <div id="breakModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">Configure Breaks</div>
            <div class="modal-body">
                <div class="input-group">
                    <label>Number of Breaks:</label>
                    <input type="number" id="breakCount" min="0" max="10" value="3">
                </div>
                <div class="input-group">
                    <label>Duration per Break (minutes):</label>
                    <input type="number" id="breakDuration" min="1" max="60" value="5">
                </div>
            </div>
            <div class="modal-footer">
                <button class="secondary" onclick="closeBreakModal()">Cancel</button>
                <button onclick="saveBreakSettings()">Save</button>
            </div>
        </div>
    </div>

    <div id="alertModal" class="modal">
        <div class="modal-content">
            <div class="modal-header" id="alertModalHeader">Alert</div>
            <div class="modal-body" id="alertModalBody"></div>
            <div class="modal-footer">
                <button onclick="closeAlertModal()">OK</button>
            </div>
        </div>
    </div>


    <script>
        // Global state management
        let timers = [];
        let timerIdCounter = 0;
        let isUILocked = false;
        let countDirection = 'down'; // 'down' or 'up'
        let globalVolume = 0.5;
        let currentTheme = 'light';
        let currentBreakTimerId = null;

        // Audio context for chime
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioContext = null;

        // --- Modal Functions ---
        function showAlert(title, message) {
            document.getElementById('alertModalHeader').textContent = title;
            document.getElementById('alertModalBody').textContent = message;
            document.getElementById('alertModal').classList.add('active');
        }

        function closeAlertModal() {
            document.getElementById('alertModal').classList.remove('active');
        }

        // Initialize audio context on first user interaction
        function initAudioContext() {
            if (!audioContext) {
                audioContext = new AudioContext();
            }
        }

        // Play chime sound
        function playChime(volume = globalVolume) {
            initAudioContext();
            if (!audioContext) return;

            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.frequency.value = 800;
            oscillator.type = 'sine';

            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 0.01);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.5);

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.5);
        }

        // Timer class
        class Timer {
            constructor(id, label = 'Timer', duration = 3600) {
                this.id = id;
                this.label = label;
                this.duration = duration; // in seconds
                this.elapsed = 0;
                this.remaining = duration;
                this.isRunning = false;
                this.isPaused = false;
                this.isFinished = false;
                this.chimeEnabled = true;
                this.lastUpdateTime = null;
                this.intervalId = null;

                // Break settings
                this.breakCount = 3;
                this.breakDuration = 5; // minutes
                this.breaksUsed = [];
                this.activeBreak = null;
                this.onBreak = false; // True only when a break is active
            }

            start() {
                if (this.isFinished || this.activeBreak) return;

                this.isRunning = true;
                this.isPaused = false;
                this.lastUpdateTime = Date.now();

                if (!this.intervalId) {
                    this.intervalId = setInterval(() => this.update(), 100);
                }
            }

            pause() {
                this.isRunning = false;
                this.isPaused = true;

                if (this.intervalId) {
                    clearInterval(this.intervalId);
                    this.intervalId = null;
                }
            }

            reset() {
                this.pause();
                this.elapsed = 0;
                this.remaining = this.duration;
                this.isFinished = false;
                this.isPaused = false;
                this.breaksUsed = [];
                this.activeBreak = null;
                this.onBreak = false;
            }

            update() {
                if (!this.isRunning || this.isFinished) return;

                const now = Date.now();
                const delta = (now - this.lastUpdateTime) / 1000;
                this.lastUpdateTime = now;

                if (countDirection === 'down') {
                    this.remaining -= delta;
                    this.elapsed = this.duration - this.remaining;
                    if (this.remaining <= 0) this.finish();
                } else {
                    this.elapsed += delta;
                    this.remaining = this.duration - this.elapsed;
                    if (this.elapsed >= this.duration) this.finish();
                }
            }

            finish() {
                this.remaining = 0;
                this.elapsed = this.duration;
                this.isRunning = false;
                this.isFinished = true;
                this.pause();

                if (this.chimeEnabled) playChime();
                updateTimerDisplay(this.id);
            }

            startBreak(breakIndex) {
                if (this.activeBreak || this.breaksUsed.includes(breakIndex)) return;

                this.pause();
                this.onBreak = true;

                this.activeBreak = {
                    index: breakIndex,
                    duration: this.breakDuration * 60,
                    remaining: this.breakDuration * 60,
                    lastUpdateTime: Date.now(),
                    intervalId: null
                };

                const breakUpdate = () => {
                    if (!this.activeBreak) return; // Guard against race conditions
                    const now = Date.now();
                    const delta = (now - this.activeBreak.lastUpdateTime) / 1000;
                    this.activeBreak.lastUpdateTime = now;
                    this.activeBreak.remaining -= delta;

                    if (this.activeBreak.remaining <= 0) {
                        this.activeBreak.remaining = 0;
                        this.endBreak(breakIndex);
                    }
                    updateTimerDisplay(this.id);
                };

                this.activeBreak.intervalId = setInterval(breakUpdate, 100);
                updateTimerDisplay(this.id);
            }

            endBreak(breakIndex) {
                if (!this.activeBreak || this.activeBreak.index !== breakIndex) return;

                clearInterval(this.activeBreak.intervalId);
                if (!this.breaksUsed.includes(breakIndex)) {
                   this.breaksUsed.push(breakIndex);
                }
                this.activeBreak = null;
                this.onBreak = false;
                // --- START OF CHANGE ---
                // Automatically resume the main timer instead of just pausing.
                this.start();
                // --- END OF CHANGE ---
                updateTimerDisplay(this.id);
            }

            cancelBreak() {
                if (!this.activeBreak) return;
                const breakIndex = this.activeBreak.index;
                this.endBreak(breakIndex);
            }
        }

        // Generate break buttons HTML
        function generateBreakButtons(timer) {
            if (timer.breakCount === 0) return '';
            let html = '';
            for (let i = 0; i < timer.breakCount; i++) {
                const isUsed = timer.breaksUsed.includes(i);
                const isActive = timer.activeBreak && timer.activeBreak.index === i;
                const isDisabled = timer.isFinished || (timer.activeBreak && !isActive);

                if (isActive) {
                    const remaining = Math.ceil(timer.activeBreak.remaining);
                    const minutes = Math.floor(remaining / 60);
                    const seconds = remaining % 60;
                    html += `<button class="break-btn active" id="break-btn-${timer.id}-${i}" onclick="cancelBreak(${timer.id})"><span>${minutes}m ${seconds}s</span></button>`;
                } else if (isUsed) {
                    html += `<button class="break-btn" disabled><span>Break Used</span></button>`;
                } else {
                    html += `<button class="break-btn" onclick="startBreak(${timer.id}, ${i})" ${isDisabled ? 'disabled' : ''}><span>${timer.breakDuration} min Break</span></button>`;
                }
            }
            return html;
        }

        // Create timer card HTML
        function createTimerCard(timer, isCompact = false) {
            const card = document.createElement('div');
            card.className = 'timer-card';
            if (isCompact) card.classList.add('compact');
            card.id = `timer-${timer.id}`;

            const timeAndProgressHTML = isCompact ? `
                <div class="timer-and-progress">
                    <div class="timer-display" onclick="editTime(${timer.id})" id="display-${timer.id}"></div>
                    <div class="progress-container">
                        <div class="progress-bar"><div class="progress-fill" id="progress-${timer.id}"></div></div>
                        <span class="duration-label">${formatTime(timer.duration)}</span>
                    </div>
                </div>
            ` : `
                <div class="timer-display" onclick="editTime(${timer.id})" id="display-${timer.id}"></div>
                <div class="progress-container">
                    <div class="progress-bar"><div class="progress-fill" id="progress-${timer.id}"></div></div>
                    <span class="duration-label">${formatTime(timer.duration)}</span>
                </div>
            `;

            card.innerHTML = `
                <div class="timer-header">
                    <div class="timer-label" onclick="editLabel(${timer.id})" id="label-${timer.id}">${timer.label}</div>
                    <button class="icon-button danger" onclick="removeTimer(${timer.id})">Ã—</button>
                </div>
                ${timeAndProgressHTML}
                <div class="timer-controls" id="controls-${timer.id}">
                    <div class="timer-controls-left">
                        <button id="start-${timer.id}" onclick="toggleTimer(${timer.id})"></button>
                        <button id="reset-${timer.id}" onclick="resetTimer(${timer.id})">Reset</button>
                        <button class="icon-button ${timer.chimeEnabled ? '' : 'secondary'}" onclick="toggleChime(${timer.id})">ðŸ””</button>
                    </div>
                     <div class="timer-controls-right">
                        <button class="secondary" onclick="openBreakModal(${timer.id})">Edit Breaks</button>
                        ${generateBreakButtons(timer)}
                    </div>
                </div>
            `;
            return card;
        }

        // Format time display
        function formatTime(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);

            if (hours > 0) {
                return `${hours}h ${String(minutes).padStart(2, '0')}m ${String(secs).padStart(2, '0')}s`;
            }
            return minutes > 0 ? `${minutes}m ${String(secs).padStart(2, '0')}s` : `${secs}s`;
        }

        // Get progress percentage
        function getProgress(timer) {
            if (timer.duration === 0) return 0;
            const progress = countDirection === 'down' ?
                ((timer.duration - timer.remaining) / timer.duration) * 100 :
                (timer.elapsed / timer.duration) * 100;
            return Math.max(0, Math.min(100, progress));
        }

        // Update timer display
        function updateTimerDisplay(timerId) {
            const timer = timers.find(t => t.id === timerId);
            if (!timer) return;
            const card = document.getElementById(`timer-${timerId}`);
            if (!card) return;

            card.className = 'timer-card';
            if (timers.length > 4) card.classList.add('compact');
            if (timer.isFinished) card.classList.add('finished');
            else if (timer.onBreak) card.classList.add('on-break');
            else if (timer.isPaused) card.classList.add('paused');

            const display = document.getElementById(`display-${timerId}`);
            if (timer.isFinished) {
                display.innerHTML = "Time's Up!";
                display.classList.add('finished');
                display.classList.remove('running');
            } else {
                display.innerHTML = formatTime(countDirection === 'down' ? timer.remaining : timer.elapsed);
                display.classList.remove('finished');
                display.classList.toggle('running', timer.isRunning);
            }
            display.style.pointerEvents = (timer.isRunning || isUILocked || timer.activeBreak) ? 'none' : 'auto';

            document.getElementById(`progress-${timerId}`).style.width = `${getProgress(timer)}%`;

            const startBtn = document.getElementById(`start-${timerId}`);
            if (timer.isRunning) startBtn.textContent = 'Pause';
            else if (timer.isPaused) startBtn.textContent = 'Resume';
            else startBtn.textContent = 'Start';
            startBtn.disabled = timer.isFinished || !!timer.activeBreak;

            const controlsRightContainer = card.querySelector('.timer-controls-right');
            if (controlsRightContainer) {
                if (timer.activeBreak) {
                    // A break is currently active. Efficiently update its countdown.
                    const breakIndex = timer.activeBreak.index;
                    const activeBtn = document.getElementById(`break-btn-${timer.id}-${breakIndex}`);

                    const remaining = Math.ceil(timer.activeBreak.remaining);
                    const minutes = Math.floor(remaining / 60);
                    const seconds = remaining % 60;
                    const newText = `${minutes}m ${seconds}s`;

                    if (activeBtn && activeBtn.classList.contains('active')) {
                        const span = activeBtn.querySelector('span');
                        if (span && span.textContent !== newText) {
                            span.textContent = newText;
                        }
                    } else {
                        // This handles the very first frame when a break starts.
                        // A full re-render is necessary here to add the 'active' class etc.
                        const newHTML = `<button class="secondary" onclick="openBreakModal(${timer.id})">Edit Breaks</button>${generateBreakButtons(timer)}`;
                        controlsRightContainer.innerHTML = newHTML;
                    }
                } else {
                    // No break is active.
                    // We only need to re-render the controls if the UI is out of sync
                    // (e.g., a break just ended, and the UI still shows an active button).
                    const hasActiveButton = controlsRightContainer.querySelector('.break-btn.active');
                    if (hasActiveButton) {
                        const newHTML = `<button class="secondary" onclick="openBreakModal(${timer.id})">Edit Breaks</button>${generateBreakButtons(timer)}`;
                        controlsRightContainer.innerHTML = newHTML;
                    }
                }
            }

            const chimeBtn = card.querySelector('button[onclick*="toggleChime"]');
            chimeBtn.classList.toggle('secondary', !timer.chimeEnabled);
        }

        // Timer management functions
        function addTimer() {
            if (isUILocked) return;
            const id = timerIdCounter++;
            timers.push(new Timer(id, `Timer ${id + 1}`, 3600));
            renderTimers();
            saveState();
        }

        function removeTimer(timerId) {
            if (isUILocked) return;
            const timer = timers.find(t => t.id === timerId);
            if (timer) timer.pause();
            timers = timers.filter(t => t.id !== timerId);
            renderTimers();
            saveState();
        }

        function removeAllTimers() {
            if (isUILocked) return;
            timers.forEach(timer => timer.pause());
            timers = [];
            renderTimers();
            saveState();
        }

        function toggleTimer(timerId) {
            const timer = timers.find(t => t.id === timerId);
            if (!timer || timer.isFinished || timer.activeBreak) return;
            timer.isRunning ? timer.pause() : timer.start();
            updateTimerDisplay(timerId);
            saveState();
        }

        function resetTimer(timerId) {
            if (isUILocked) return;
            const timer = timers.find(t => t.id === timerId);
            if (timer) {
                timer.reset();
                updateTimerDisplay(timerId);
                saveState();
            }
        }

        function toggleChime(timerId) {
            const timer = timers.find(t => t.id === timerId);
            if (timer) {
                timer.chimeEnabled = !timer.chimeEnabled;
                updateTimerDisplay(timer.id);
                saveState();
            }
        }

        // Break management
        function openBreakModal(timerId) {
            if (isUILocked) return;
            currentBreakTimerId = timerId;
            const timer = timers.find(t => t.id === timerId);
            if (timer) {
                document.getElementById('breakCount').value = timer.breakCount;
                document.getElementById('breakDuration').value = timer.breakDuration;
            }
            document.getElementById('breakModal').classList.add('active');
        }

        function closeBreakModal() {
            document.getElementById('breakModal').classList.remove('active');
            currentBreakTimerId = null;
        }

        function saveBreakSettings() {
            const timer = timers.find(t => t.id === currentBreakTimerId);
            if (timer) {
                timer.breakCount = parseInt(document.getElementById('breakCount').value);
                timer.breakDuration = parseInt(document.getElementById('breakDuration').value);
                if (!timer.activeBreak) timer.breaksUsed = [];
                // Force a re-render of the buttons after saving
                const card = document.getElementById(`timer-${timer.id}`);
                const controlsRightContainer = card.querySelector('.timer-controls-right');
                const newHTML = `<button class="secondary" onclick="openBreakModal(${timer.id})">Edit Breaks</button>${generateBreakButtons(timer)}`;
                controlsRightContainer.innerHTML = newHTML;
                updateTimerDisplay(currentBreakTimerId);
                saveState();
            }
            closeBreakModal();
        }

        function startBreak(timerId, breakIndex) {
            const timer = timers.find(t => t.id === timerId);
            if (timer) {
                timer.startBreak(breakIndex);
                saveState();
            }
        }

        function cancelBreak(timerId) {
            const timer = timers.find(t => t.id === timerId);
            if (timer) {
                timer.cancelBreak();
                saveState();
            }
        }

        // Label and time editing
        function editLabel(timerId) {
            if (isUILocked) return;
            const labelElement = document.getElementById(`label-${timerId}`);
            const timer = timers.find(t => t.id === timerId);
            if (!timer || labelElement.querySelector('input')) return;

            const input = document.createElement('input');
            input.type = 'text';
            input.value = timer.label;
            const save = () => {
                timer.label = input.value.trim() || `Timer ${timerId + 1}`;
                labelElement.innerHTML = timer.label;
                saveState();
            };
            input.onblur = save;
            input.onkeydown = (e) => {
                if (e.key === 'Enter') input.blur();
                else if (e.key === 'Escape') labelElement.innerHTML = timer.label;
            };

            labelElement.innerHTML = '';
            labelElement.appendChild(input);
            input.focus();
            input.select();
        }

        function editTime(timerId) {
            if (isUILocked) return;
            const timer = timers.find(t => t.id === timerId);
            if (!timer || timer.isFinished || timer.isRunning || timer.activeBreak) return;

            const currentHours = Math.floor(timer.duration / 3600);
            const currentMinutes = Math.floor((timer.duration % 3600) / 60);
            const defaultValue = String(currentHours).padStart(2, '0') + String(currentMinutes).padStart(2, '0');

            const input = prompt('Enter time in HHMM format (e.g., 0245 for 2h 45m):', defaultValue);
            if (!input || !/^\d{4}$/.test(input)) return;

            const hours = parseInt(input.substr(0, 2));
            const minutes = parseInt(input.substr(2, 2));

            if (hours > 23 || minutes > 59) {
                showAlert('Invalid Time', 'Invalid time format. Hours must be 0-23, minutes must be 0-59.');
                return;
            }
            timer.duration = (hours * 3600) + (minutes * 60);
            timer.reset();
            updateTimerDisplay(timerId);
            saveState();
        }

        // Global controls
        function startAllTimers() {
            timers.forEach(timer => timer.start());
            saveState();
        }

        function pauseAllTimers() {
            timers.forEach(timer => timer.pause());
            saveState();
        }

        function resetAllTimers() {
            if (isUILocked) return;
            timers.forEach(timer => {
                timer.reset();
                updateTimerDisplay(timer.id);
            });
            saveState();
        }

        function toggleDirection() {
            countDirection = countDirection === 'down' ? 'up' : 'down';
            document.getElementById('directionToggle').classList.toggle('active');
            document.getElementById('directionLabel').textContent = countDirection === 'down' ? 'Count Down' : 'Count Up';
            timers.forEach(timer => updateTimerDisplay(timer.id));
            saveState();
        }

        function updateVolume(value) {
            globalVolume = value / 100;
            document.getElementById('volumeLabel').textContent = `${value}%`;
            playChime(globalVolume * 0.3);
            saveState();
        }

        function toggleUILock() {
            isUILocked = !isUILocked;
            const lockBtn = document.getElementById('lockBtn');
            lockBtn.textContent = isUILocked ? 'ðŸ”’ Locked' : 'ðŸ”“ Unlocked';
            lockBtn.classList.toggle('warning', isUILocked);
            document.getElementById('addTimerBtn').disabled = isUILocked;
            document.getElementById('removeAllBtn').disabled = isUILocked;
            document.getElementById('resetAllBtn').disabled = isUILocked;
            renderTimers();
            saveState();
        }

        function toggleTheme() {
            currentTheme = currentTheme === 'light' ? 'dark' : 'light';
            document.body.setAttribute('data-theme', currentTheme);
            document.getElementById('themeToggle').classList.toggle('active');
            saveState();
        }

        // Render all timers
        function renderTimers() {
            const container = document.getElementById('timerContainer');
            container.innerHTML = '';
            if (timers.length === 0) {
                container.className = 'timer-grid';
                container.innerHTML = `<div class="empty-state"><h2>No timers yet</h2><p>Click "Add Timer" to get started</p></div>`;
                return;
            }
            container.className = timers.length === 1 ? 'timer-grid single' : 'timer-grid multiple';
            const isCompact = timers.length > 4;
            timers.forEach(timer => {
                const card = createTimerCard(timer, isCompact);
                container.appendChild(card);
                updateTimerDisplay(timer.id);

                if (isUILocked) {
                    card.querySelector('button.danger').disabled = true;
                    card.querySelector('button[onclick*="openBreakModal"]').disabled = true;
                    card.querySelector('#reset-' + timer.id).disabled = true;
                    card.querySelector('.timer-label').style.pointerEvents = 'none';
                }
            });
        }

        // State persistence
        function saveState() {
            const state = {
                timers: timers.map(t => ({
                    id: t.id, label: t.label, duration: t.duration, elapsed: t.elapsed, remaining: t.remaining,
                    isPaused: t.isPaused, isFinished: t.isFinished, chimeEnabled: t.chimeEnabled, breakCount: t.breakCount,
                    breakDuration: t.breakDuration, breaksUsed: t.breaksUsed, onBreak: false // Don't save active break state
                })),
                timerIdCounter, isUILocked, countDirection, globalVolume, currentTheme
            };
            localStorage.setItem('examTimerState', JSON.stringify(state));
        }

        function loadState() {
            const savedState = localStorage.getItem('examTimerState');
            if (!savedState) return;
            try {
                const state = JSON.parse(savedState);
                timerIdCounter = state.timerIdCounter || 0;
                isUILocked = state.isUILocked || false;
                countDirection = state.countDirection || 'down';
                globalVolume = state.globalVolume || 0.5;
                currentTheme = state.currentTheme || 'light';
                timers = state.timers.map(t_state => {
                    const timer = new Timer(t_state.id, t_state.label, t_state.duration);
                    Object.assign(timer, t_state);
                    timer.isRunning = false;
                    return timer;
                });
                document.body.setAttribute('data-theme', currentTheme);
                document.getElementById('themeToggle').classList.toggle('active', currentTheme === 'dark');
                document.getElementById('directionToggle').classList.toggle('active', countDirection === 'up');
                document.getElementById('directionLabel').textContent = countDirection === 'down' ? 'Count Down' : 'Count Up';
                document.getElementById('volumeSlider').value = globalVolume * 100;
                document.getElementById('volumeLabel').textContent = `${Math.round(globalVolume * 100)}%`;
                if (isUILocked) {
                    isUILocked = false; // Set to inverse so toggle sets it correctly
                    toggleUILock();
                } else {
                    renderTimers();
                }
            } catch (e) { console.error('Failed to load state:', e); }
        }

        // Update all timer displays periodically
        function updateAllDisplays() {
            timers.forEach(timer => {
                if (timer.isRunning || timer.activeBreak) updateTimerDisplay(timer.id);
            });
        }

        // Initialize on load
        window.addEventListener('load', () => {
            loadState();
            setInterval(updateAllDisplays, 250);
            document.addEventListener('click', initAudioContext, { once: true });
        });

        window.addEventListener('beforeunload', saveState);
    </script>
</body>
</html>
